version: 1
description: 'Website mapping MVP scaffold: new mapping modules + minimal integration into androidApp.'
new_files:
- path: kmp/mapping/core/build.gradle.kts
  content: |
    plugins {
        kotlin("multiplatform")
        kotlin("plugin.serialization")
    }
    
    kotlin {
        jvm()
        
        sourceSets {
            val commonMain by getting {
                dependencies {
                    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.3")
                    implementation("org.jetbrains.kotlinx:kotlinx-datetime:0.6.1")
                }
            }
        }
    }

- path: kmp/mapping/core/src/commonMain/kotlin/de/kolping/cockpit/mapping/core/Ids.kt
  content: |
    package de.kolping.cockpit.mapping.core
    
    import kotlin.random.Random
    import kotlinx.datetime.Clock
    
    /**
     * Type aliases for various IDs used in the mapping system.
     */
    typealias ChainId = String
    typealias NodeId = String
    typealias EdgeId = String
    typealias SessionId = String
    typealias CallId = String
    
    /**
     * Generate a new unique ID with the given prefix.
     * Format: prefix_timestamp_random
     */
    fun newId(prefix: String): String {
        val timestamp = Clock.System.now().toEpochMilliseconds()
        val random = Random.nextInt(10000, 99999)
        return "${prefix}_${timestamp}_${random}"
    }
    
    /**
     * Get current time in milliseconds (KMP compatible).
     */
    fun currentTimeMillis(): Long = Clock.System.now().toEpochMilliseconds()

- path: kmp/mapping/core/src/commonMain/kotlin/de/kolping/cockpit/mapping/core/Models.kt
  content: |
    package de.kolping.cockpit.mapping.core
    
    import kotlinx.serialization.Serializable
    
    /**
     * Complete data model for Website Mapping MVP.
     * Combines RecordChain, ChainPoint, ChainEdge, RecordingSession, Events, and HttpCall.
     */
    
    @Serializable
    data class RecordChain(
        val id: ChainId,
        val name: String,
        val rootNodeId: NodeId? = null,
        val createdAtEpochMs: Long = currentTimeMillis(),
    )
    
    @Serializable
    data class ChainPoint(
        val id: NodeId,
        val name: String,
        val url: String,
        val urlPattern: String? = null,
        val tags: List<String> = emptyList(),
        val signature: String? = null,
        val isHub: Boolean = false,
        val observedOps: List<String> = emptyList(),
        val observedAjaxMethods: List<String> = emptyList(),
    )
    
    @Serializable
    data class ChainEdge(
        val id: EdgeId,
        val fromNodeId: NodeId,
        val toNodeId: NodeId,
        val label: String? = null,
        val createdBy: CreatedBy = CreatedBy.AUTO,
        val reason: EdgeReason? = null,
    )
    
    @Serializable
    enum class CreatedBy { MANUAL, AUTO }
    
    @Serializable
    enum class EdgeReason {
        HUB_MATCH,
        NAV_CLICK,
        CONTEXT_SWITCH,
        LINEAR,
        MANUAL_SELECTION
    }
    
    @Serializable
    data class RecordingSession(
        val id: SessionId,
        val chainId: ChainId? = null,
        val startedAtEpochMs: Long,
        val endedAtEpochMs: Long? = null,
        val targetUrl: String? = null,
        val filters: CaptureFilters = CaptureFilters(),
        val events: List<Event> = emptyList(),
    )
    
    @Serializable
    data class CaptureFilters(
        val hostAllowlist: List<String> = emptyList(),
        val captureJsonBodies: Boolean = true,
        val maxBodyBytes: Int = 256_000,
        val redact: Boolean = true,
    )
    
    @Serializable
    sealed class Event {
        abstract val tsEpochMs: Long
    
        @Serializable
        data class NavigationEvent(
            override val tsEpochMs: Long,
            val url: String,
            val phase: Phase,
        ) : Event()
    
        @Serializable
        data class MarkerEvent(
            override val tsEpochMs: Long,
            val name: String,
            val metadata: Map<String, String> = emptyMap(),
        ) : Event()
    
        @Serializable
        data class NetworkRequestEvent(
            override val tsEpochMs: Long,
            val id: CallId,
            val method: String,
            val url: String,
            val headers: Map<String, String> = emptyMap(),
            val body: String? = null,
        ) : Event()
    
        @Serializable
        data class NetworkResponseEvent(
            override val tsEpochMs: Long,
            val requestId: CallId,
            val status: Int,
            val headers: Map<String, String> = emptyMap(),
            val body: String? = null,
            val contentType: String? = null,
            val graphqlOperationName: String? = null,
            val moodleAjaxMethod: String? = null,
        ) : Event()
    
        @Serializable
        data class ClickEvent(
            override val tsEpochMs: Long,
            val cssPath: String,
            val targetUrl: String? = null,
        ) : Event()
    
        @Serializable
        enum class Phase { STARTED, FINISHED }
    }
    
    @Serializable
    data class HttpCall(
        val id: CallId,
        val sessionId: SessionId,
        val url: String,
        val method: String,
        val requestHeaders: Map<String, String> = emptyMap(),
        val requestBody: String? = null,
        val responseStatus: Int? = null,
        val responseHeaders: Map<String, String> = emptyMap(),
        val responseBody: String? = null,
        val contentType: String? = null,
        val graphqlOperationName: String? = null,
        val moodleAjaxMethod: String? = null,
        val signature: String? = null,
        val timestampMs: Long = currentTimeMillis(),
    )

- path: kmp/mapping/core/src/commonMain/kotlin/de/kolping/cockpit/mapping/core/Signature.kt
  content: |
    package de.kolping.cockpit.mapping.core
    
    import kotlinx.serialization.json.Json
    import kotlinx.serialization.json.JsonArray
    import kotlinx.serialization.json.JsonObject
    import kotlinx.serialization.json.jsonObject
    import kotlinx.serialization.json.jsonPrimitive
    
    /**
     * URL normalization and signature computation for nodes and calls.
     */
    object Signature {
        
        /**
         * Normalize URL by removing fragments and sorting query parameters.
         */
        fun normalizeUrl(url: String): String {
            return try {
                // Remove fragment
                val withoutFragment = url.substringBefore('#')
                
                // Split URL and query string
                val parts = withoutFragment.split('?', limit = 2)
                if (parts.size == 1) {
                    withoutFragment
                } else {
                    val base = parts[0]
                    val queryParams = parts[1].split('&')
                        .map { it.split('=', limit = 2) }
                        .sortedBy { it[0] }
                        .joinToString("&") { it.joinToString("=") }
                    "$base?$queryParams"
                }
            } catch (e: Exception) {
                url.substringBefore('#')
            }
        }
        
        /**
         * Compute node signature from URL and observed operations.
         */
        fun computeNodeSignature(
            url: String,
            observedOps: List<String> = emptyList(),
            observedAjaxMethods: List<String> = emptyList()
        ): String {
            val normalized = normalizeUrl(url)
            val ops = observedOps.sorted().joinToString(",")
            val ajax = observedAjaxMethods.sorted().joinToString(",")
            return "node:${normalized.hashCode()}:${ops.hashCode()}:${ajax.hashCode()}"
        }
        
        /**
         * Compute call signature from URL, method, and optional GraphQL/Moodle identifiers.
         */
        fun computeCallSignature(
            url: String,
            method: String,
            contentType: String? = null,
            opName: String? = null,
            ajaxMethod: String? = null
        ): String {
            val normalized = normalizeUrl(url)
            val parts = mutableListOf(method.uppercase(), normalized)
            
            opName?.let { parts.add("op:$it") }
            ajaxMethod?.let { parts.add("ajax:$it") }
            contentType?.let { if (it.contains("json")) parts.add("json") }
            
            return "call:" + parts.joinToString(":").hashCode().toString()
        }
        
        /**
         * Extract GraphQL operation name from request body.
         */
        fun extractGraphQLOperationName(body: String?): String? {
            if (body.isNullOrBlank()) return null
            return try {
                val json = Json.parseToJsonElement(body).jsonObject
                json["operationName"]?.jsonPrimitive?.content
            } catch (e: Exception) {
                null
            }
        }
        
        /**
         * Extract Moodle AJAX method name from request body or URL.
         */
        fun extractMoodleAjaxMethod(url: String, body: String?): String? {
            // Try to extract from body first
            if (!body.isNullOrBlank()) {
                try {
                    val json = Json.parseToJsonElement(body)
                    if (json is JsonArray) {
                        val firstElem = json.firstOrNull()?.jsonObject
                        firstElem?.get("methodname")?.jsonPrimitive?.content?.let { return it }
                    } else if (json is JsonObject) {
                        json["methodname"]?.jsonPrimitive?.content?.let { return it }
                    }
                } catch (e: Exception) {
                    // Ignore parse errors
                }
            }
            
            // Try to extract from URL query parameter
            if (url.contains("methodname=")) {
                val match = Regex("methodname=([^&]+)").find(url)
                return match?.groupValues?.get(1)
            }
            
            return null
        }
    }

- path: kmp/mapping/core/src/commonMain/kotlin/de/kolping/cockpit/mapping/core/Redaction.kt
  content: |
    package de.kolping.cockpit.mapping.core
    
    object Redaction {
        private val sensitiveHeaderKeys = setOf("authorization", "cookie", "set-cookie")
        private val sensitiveJsonKeys = setOf(
            "access_token","refresh_token","id_token","code","state","nonce","session_state"
        )
    
        fun redactHeaders(headers: Map<String, String>): Map<String, String> =
            headers.mapValues { (k, v) -> if (k.lowercase() in sensitiveHeaderKeys) "<redacted>" else v }
    
        fun redactJsonLike(text: String): String {
            // very lightweight MVP redaction: mask common token keys in JSON-ish bodies
            var out = text
            for (k in sensitiveJsonKeys) {
                out = out.replace(Regex("(\"$k\"\\s*:\\s*)\"[^\"]*\""), "$1\"<redacted>\"")
            }
            return out
        }
    }

- path: kmp/mapping/core/src/commonMain/kotlin/de/kolping/cockpit/mapping/core/AutoMappingEngine.kt
  content: |
    package de.kolping.cockpit.mapping.core
    
    /**
     * MVP auto-mapping heuristics:
     * - resolve/create nodes by normalized URL + request signature
     * - infer parent edges; branch from hub/root on context switch or nav click marker
     * - detect hub nodes based on URL patterns and signatures
     * - support manual parent selection
     *
     * This is intentionally minimal: explainable + reversible.
     */
    class AutoMappingEngine {
        
        data class Inference(
            val parentNodeId: NodeId?,
            val reason: EdgeReason
        )
        
        /**
         * Detect if a URL/signature combination represents a hub node.
         * Hubs are common landing pages or dashboards.
         */
        fun detectHub(url: String, signature: String): Boolean {
            val normalizedUrl = Signature.normalizeUrl(url).lowercase()
            
            // Common hub patterns
            val hubPatterns = listOf(
                "/my/",
                "/dashboard",
                "/home",
                "/portal",
                "/index"
            )
            
            return hubPatterns.any { normalizedUrl.contains(it) }
        }
        
        /**
         * Infer parent node with support for manual parent selection.
         * If manualParentId is provided, use it; otherwise apply heuristics.
         */
        fun inferParent(
            lastActiveNodeId: NodeId?,
            closestHubAncestorId: NodeId?,
            isNewNodeHub: Boolean,
            isNavClick: Boolean,
            isContextSwitch: Boolean,
            manualParentId: NodeId? = null
        ): Inference {
            // Manual selection takes precedence
            if (manualParentId != null) {
                return Inference(
                    parentNodeId = manualParentId,
                    reason = EdgeReason.MANUAL_SELECTION
                )
            }
            
            // Hub nodes have no parent
            if (isNewNodeHub) {
                return Inference(
                    parentNodeId = null,
                    reason = EdgeReason.HUB_MATCH
                )
            }
            
            // Navigation click branches from hub
            if (isNavClick) {
                return Inference(
                    parentNodeId = closestHubAncestorId,
                    reason = EdgeReason.NAV_CLICK
                )
            }
            
            // Context switch branches from hub
            if (isContextSwitch) {
                return Inference(
                    parentNodeId = closestHubAncestorId,
                    reason = EdgeReason.CONTEXT_SWITCH
                )
            }
            
            // Linear progression from last active node
            return Inference(
                parentNodeId = lastActiveNodeId,
                reason = EdgeReason.LINEAR
            )
        }
        
        /**
         * Update the map graph from a recording session.
         * Processes events and creates/updates nodes and edges.
         */
        fun updateGraph(
            mapGraph: MapGraph,
            session: RecordingSession
        ): MapGraph {
            var currentGraph = mapGraph
            var lastActiveNodeId: NodeId? = null
            
            for (event in session.events) {
                when (event) {
                    is Event.NavigationEvent -> {
                        if (event.phase == Event.Phase.FINISHED) {
                            val signature = Signature.computeNodeSignature(event.url)
                            val isHub = detectHub(event.url, signature)
                            
                            // Find or create node
                            val existingNode = currentGraph.findNodeBySignature(signature)
                            val nodeId = existingNode?.id ?: newId("node")
                            
                            if (existingNode == null) {
                                val newNode = ChainPoint(
                                    id = nodeId,
                                    name = event.url.substringAfter("//").substringBefore("?").take(50),
                                    url = event.url,
                                    signature = signature,
                                    isHub = isHub
                                )
                                currentGraph = currentGraph.upsertNode(newNode)
                            }
                            
                            lastActiveNodeId = nodeId
                        }
                    }
                    else -> {
                        // Other event types handled elsewhere
                    }
                }
            }
            
            return currentGraph
        }
    }

- path: kmp/mapping/core/src/commonMain/kotlin/de/kolping/cockpit/mapping/core/ExportBundle.kt
  content: |
    package de.kolping.cockpit.mapping.core
    
    import kotlinx.serialization.Serializable
    import kotlinx.serialization.encodeToString
    import kotlinx.serialization.json.Json
    
    /**
     * Export bundle writer for mapping data.
     * Writes map graph, chains, sessions, and schemas to JSON files.
     */
    object ExportBundle {
        private val json = Json { prettyPrint = true; encodeDefaults = true }
        
        /**
         * Serialize a recording session to JSON.
         */
        fun sessionJson(session: RecordingSession): String = json.encodeToString(session)
        
        /**
         * Serialize a map graph to JSON.
         */
        fun mapGraphJson(mapGraph: MapGraph): String = json.encodeToString(mapGraph)
        
        /**
         * Serialize a record chain to JSON.
         */
        fun chainJson(chain: RecordChain): String = json.encodeToString(chain)
        
        /**
         * Serialize an HTTP call to JSON.
         */
        fun callJson(call: HttpCall): String = json.encodeToString(call)
        
        /**
         * Serialize schema fields to JSON.
         */
        fun schemaJson(fields: List<SchemaDeriver.FieldSchema>): String = json.encodeToString(fields)
        
        /**
         * Data class for complete export bundle structure.
         */
        @Serializable
        data class ExportManifest(
            val version: String = "1.0",
            val exportedAtEpochMs: Long = currentTimeMillis(),
            val files: Map<String, String> = emptyMap()
        )
        
        /**
         * Create export manifest.
         */
        fun manifestJson(files: Map<String, String>): String {
            val manifest = ExportManifest(files = files)
            return json.encodeToString(manifest)
        }
    }

- path: kmp/mapping/core/src/commonMain/kotlin/de/kolping/cockpit/mapping/core/SchemaDeriver.kt
  content: |
    package de.kolping.cockpit.mapping.core
    
    import kotlinx.serialization.Serializable
    import kotlinx.serialization.json.*
    
    /**
     * Extract JSON schema from response bodies.
     * Returns field paths with inferred types.
     */
    object SchemaDeriver {
        
        @Serializable
        data class FieldSchema(
            val path: String,
            val type: String,
            val isArray: Boolean = false,
            val isNullable: Boolean = false
        )
        
        /**
         * Derive schema from a JSON response body.
         */
        fun deriveSchema(jsonBody: String): List<FieldSchema> {
            if (jsonBody.isBlank()) return emptyList()
            
            return try {
                val element = Json.parseToJsonElement(jsonBody)
                val fields = mutableListOf<FieldSchema>()
                extractFields(element, "", fields)
                fields
            } catch (e: Exception) {
                emptyList()
            }
        }
        
        private fun extractFields(
            element: JsonElement,
            prefix: String,
            fields: MutableList<FieldSchema>
        ) {
            when (element) {
                is JsonObject -> {
                    element.entries.forEach { (key, value) ->
                        val path = if (prefix.isEmpty()) key else "$prefix.$key"
                        extractFields(value, path, fields)
                    }
                }
                is JsonArray -> {
                    if (element.isNotEmpty()) {
                        val first = element.first()
                        extractFields(first, prefix, fields)
                        // Mark as array
                        fields.lastOrNull()?.let { field ->
                            val index = fields.lastIndexOf(field)
                            fields[index] = field.copy(isArray = true)
                        }
                    }
                }
                is JsonPrimitive -> {
                    val isNull = element.isString.not() && element.content == "null"
                    val type = when {
                        isNull -> "null"
                        element.isString -> "string"
                        element.intOrNull != null -> "integer"
                        element.longOrNull != null -> "long"
                        element.doubleOrNull != null -> "number"
                        element.booleanOrNull != null -> "boolean"
                        else -> "unknown"
                    }
                    fields.add(FieldSchema(
                        path = prefix,
                        type = type,
                        isNullable = isNull
                    ))
                }
            }
        }
    }

- path: kmp/mapping/core/src/commonMain/kotlin/de/kolping/cockpit/mapping/core/MapGraph.kt
  content: |
    package de.kolping.cockpit.mapping.core
    
    import kotlinx.serialization.Serializable
    
    /**
     * MapGraph model with nodes, edges, and metadata.
     * Represents the discovered website structure.
     */
    @Serializable
    data class MapGraph(
        val id: String = "default",
        val name: String = "Website Map",
        val nodes: Map<NodeId, ChainPoint> = emptyMap(),
        val edges: Map<EdgeId, ChainEdge> = emptyMap(),
        val metadata: Map<String, String> = emptyMap(),
        val createdAtEpochMs: Long = currentTimeMillis(),
        val updatedAtEpochMs: Long = currentTimeMillis(),
    ) {
        
        /**
         * Insert or update a node in the graph.
         */
        fun upsertNode(node: ChainPoint): MapGraph {
            return copy(
                nodes = nodes + (node.id to node),
                updatedAtEpochMs = currentTimeMillis()
            )
        }
        
        /**
         * Insert or update an edge in the graph.
         */
        fun upsertEdge(edge: ChainEdge): MapGraph {
            return copy(
                edges = edges + (edge.id to edge),
                updatedAtEpochMs = currentTimeMillis()
            )
        }
        
        /**
         * Find a node by its signature.
         */
        fun findNodeBySignature(signature: String): ChainPoint? {
            return nodes.values.find { it.signature == signature }
        }
        
        /**
         * Find all hub ancestors for a given node.
         * Returns list of hub node IDs that are ancestors.
         */
        fun findHubAncestors(nodeId: NodeId): List<NodeId> {
            val hubs = mutableListOf<NodeId>()
            val visited = mutableSetOf<NodeId>()
            val queue = mutableListOf(nodeId)
            
            while (queue.isNotEmpty()) {
                val current = queue.removeAt(0)
                if (current in visited) continue
                visited.add(current)
                
                val node = nodes[current]
                if (node != null && node.isHub) {
                    hubs.add(current)
                }
                
                // Find parent edges
                edges.values
                    .filter { it.toNodeId == current }
                    .forEach { edge ->
                        if (edge.fromNodeId !in visited) {
                            queue.add(edge.fromNodeId)
                        }
                    }
            }
            
            return hubs
        }
        
        /**
         * Get the closest hub ancestor for a node.
         */
        fun getClosestHubAncestor(nodeId: NodeId): NodeId? {
            return findHubAncestors(nodeId).firstOrNull()
        }
    }

- path: kmp/mapping/android/build.gradle.kts
  content: |
    plugins {
        id("com.android.library")
        kotlin("android")
    }
    
    android {
        namespace = "de.kolping.cockpit.mapping.android"
        compileSdk = 35
    
        defaultConfig {
            minSdk = 26
        }
        
        buildFeatures {
            compose = true
        }
        
        composeOptions {
            kotlinCompilerExtensionVersion = libs.versions.compose.compiler.get()
        }
    }
    
    dependencies {
        implementation(project(":mapping:core"))
        implementation(libs.compose.material3)
        implementation(libs.compose.ui)
        implementation(libs.activity.compose)
        implementation(libs.kotlinx.serialization.json)
    }

- path: kmp/mapping/android/src/main/AndroidManifest.xml
  content: |
    <?xml version="1.0" encoding="utf-8"?>
    <manifest xmlns:android="http://schemas.android.com/apk/res/android">
        <!-- Minimal manifest for library module -->
        <uses-permission android:name="android.permission.INTERNET" />
    </manifest>

- path: kmp/mapping/android/src/main/java/de/kolping/cockpit/mapping/android/JsBridge.kt
  content: |
    package de.kolping.cockpit.mapping.android
    
    import android.webkit.JavascriptInterface
    import android.webkit.WebView
    import de.kolping.cockpit.mapping.core.*
    import kotlinx.serialization.json.*
    
    /**
     * JavaScript bridge for WebView to Android communication.
     * Exposes RecorderBridge interface to JavaScript.
     */
    class JsBridge(
        private val controller: RecorderController,
        private val webView: WebView
    ) {
        
        companion object {
            const val BRIDGE_NAME = "RecorderBridge"
        }
        
        /**
         * Post a message from JavaScript to Android.
         * Messages are JSON-encoded events.
         */
        @JavascriptInterface
        fun postMessage(jsonMessage: String) {
            try {
                val json = Json.parseToJsonElement(jsonMessage).jsonObject
                val type = json["type"]?.jsonPrimitive?.content ?: return
                val data = json["data"]?.jsonObject ?: JsonObject(emptyMap())
                
                when (type) {
                    "navigation" -> handleNavigationEvent(data)
                    "click" -> handleClickEvent(data)
                    "request" -> handleRequestEvent(data)
                    "response" -> handleResponseEvent(data)
                    "marker" -> handleMarkerEvent(data)
                    else -> println("Unknown event type: $type")
                }
            } catch (e: Exception) {
                println("Error parsing bridge message: ${e.message}")
            }
        }
        
        private fun handleNavigationEvent(data: JsonObject) {
            val url = data["url"]?.jsonPrimitive?.content ?: return
            val phase = data["phase"]?.jsonPrimitive?.content ?: return
            val phaseEnum = when (phase) {
                "started" -> Event.Phase.STARTED
                "finished" -> Event.Phase.FINISHED
                else -> return
            }
            
            controller.addEvent(Event.NavigationEvent(
                tsEpochMs = currentTimeMillis(),
                url = url,
                phase = phaseEnum
            ))
        }
        
        private fun handleClickEvent(data: JsonObject) {
            val cssPath = data["cssPath"]?.jsonPrimitive?.content ?: return
            val targetUrl = data["targetUrl"]?.jsonPrimitive?.contentOrNull
            
            controller.addEvent(Event.ClickEvent(
                tsEpochMs = currentTimeMillis(),
                cssPath = cssPath,
                targetUrl = targetUrl
            ))
        }
        
        private fun handleRequestEvent(data: JsonObject) {
            val id = data["id"]?.jsonPrimitive?.content ?: return
            val method = data["method"]?.jsonPrimitive?.content ?: return
            val url = data["url"]?.jsonPrimitive?.content ?: return
            val body = data["body"]?.jsonPrimitive?.contentOrNull
            
            val headers = try {
                data["headers"]?.jsonObject?.mapValues { 
                    it.value.jsonPrimitive.content 
                } ?: emptyMap()
            } catch (e: Exception) {
                emptyMap()
            }
            
            controller.addEvent(Event.NetworkRequestEvent(
                tsEpochMs = currentTimeMillis(),
                id = id,
                method = method,
                url = url,
                headers = headers,
                body = body
            ))
        }
        
        private fun handleResponseEvent(data: JsonObject) {
            val requestId = data["requestId"]?.jsonPrimitive?.content ?: return
            val status = data["status"]?.jsonPrimitive?.intOrNull ?: return
            val body = data["body"]?.jsonPrimitive?.contentOrNull
            val contentType = data["contentType"]?.jsonPrimitive?.contentOrNull
            
            val headers = try {
                data["headers"]?.jsonObject?.mapValues { 
                    it.value.jsonPrimitive.content 
                } ?: emptyMap()
            } catch (e: Exception) {
                emptyMap()
            }
            
            // Extract GraphQL operation name if present
            val graphqlOp = if (contentType?.contains("json") == true) {
                Signature.extractGraphQLOperationName(body)
            } else null
            
            // Extract Moodle AJAX method if present
            val moodleMethod = if (contentType?.contains("json") == true) {
                Signature.extractMoodleAjaxMethod(data["url"]?.jsonPrimitive?.content ?: "", body)
            } else null
            
            controller.addEvent(Event.NetworkResponseEvent(
                tsEpochMs = currentTimeMillis(),
                requestId = requestId,
                status = status,
                headers = headers,
                body = body,
                contentType = contentType,
                graphqlOperationName = graphqlOp,
                moodleAjaxMethod = moodleMethod
            ))
        }
        
        private fun handleMarkerEvent(data: JsonObject) {
            val name = data["name"]?.jsonPrimitive?.content ?: return
            val metadata = try {
                data["metadata"]?.jsonObject?.mapValues { 
                    it.value.jsonPrimitive.content 
                } ?: emptyMap()
            } catch (e: Exception) {
                emptyMap()
            }
            
            controller.addEvent(Event.MarkerEvent(
                tsEpochMs = currentTimeMillis(),
                name = name,
                metadata = metadata
            ))
        }
    }

- path: kmp/mapping/android/src/main/java/de/kolping/cockpit/mapping/android/RecorderController.kt
  content: |
    package de.kolping.cockpit.mapping.android
    
    import androidx.compose.runtime.*
    import de.kolping.cockpit.mapping.core.*
    
    /**
     * Controller for recording sessions and managing state.
     * Holds current chain, map graph, session, and chain points.
     */
    class RecorderController {
        
        // State
        var currentChain by mutableStateOf<RecordChain?>(null)
            private set
        
        var mapGraph by mutableStateOf(MapGraph())
            private set
        
        var currentSession by mutableStateOf<RecordingSession?>(null)
            private set
        
        var chainPoints = mutableStateListOf<ChainPoint>()
            private set
        
        var isRecording by mutableStateOf(false)
            private set
        
        var captureFilters by mutableStateOf(CaptureFilters())
        
        private val events = mutableListOf<Event>()
        
        /**
         * Create a new recording chain.
         */
        fun createChain(name: String) {
            val chain = RecordChain(
                id = newId("chain"),
                name = name
            )
            currentChain = chain
            chainPoints.clear()
            mapGraph = MapGraph()
        }
        
        /**
         * Start a new recording session.
         */
        fun startSession() {
            val session = RecordingSession(
                id = newId("session"),
                chainId = currentChain?.id,
                startedAtEpochMs = currentTimeMillis(),
                filters = captureFilters
            )
            currentSession = session
            events.clear()
            isRecording = true
        }
        
        /**
         * Stop the current recording session.
         */
        fun stopSession() {
            currentSession?.let { session ->
                val endedSession = session.copy(
                    endedAtEpochMs = currentTimeMillis(),
                    events = events.toList()
                )
                currentSession = endedSession
                isRecording = false
                
                // Update map graph from session
                val engine = AutoMappingEngine()
                mapGraph = engine.updateGraph(mapGraph, endedSession)
            }
        }
        
        /**
         * Save target URL as a chain point.
         */
        fun saveTargetUrl(url: String, name: String) {
            val signature = Signature.computeNodeSignature(url)
            val engine = AutoMappingEngine()
            val isHub = engine.detectHub(url, signature)
            
            val point = ChainPoint(
                id = newId("node"),
                name = name,
                url = url,
                signature = signature,
                isHub = isHub
            )
            
            chainPoints.add(point)
            mapGraph = mapGraph.upsertNode(point)
        }
        
        /**
         * Add a chain point manually.
         */
        fun addChainPoint(point: ChainPoint) {
            chainPoints.add(point)
            mapGraph = mapGraph.upsertNode(point)
        }
        
        /**
         * Add an event to the current session.
         */
        fun addEvent(event: Event) {
            if (isRecording) {
                events.add(event)
            }
        }
        
        /**
         * Export the current mapping data.
         */
        fun exportData(): Map<String, String> {
            val exports = mutableMapOf<String, String>()
            
            // Export map graph
            exports["map.json"] = ExportBundle.mapGraphJson(mapGraph)
            
            // Export current chain
            currentChain?.let {
                exports["chains/${it.id}.json"] = ExportBundle.chainJson(it)
            }
            
            // Export current session
            currentSession?.let {
                exports["sessions/${it.id}.json"] = ExportBundle.sessionJson(it)
            }
            
            // Export manifest
            exports["manifest.json"] = ExportBundle.manifestJson(exports.keys.associate { it to it })
            
            return exports
        }
    }

- path: kmp/mapping/android/src/main/java/de/kolping/cockpit/mapping/android/SessionStore.kt
  content: |
    package de.kolping.cockpit.mapping.android
    
    import android.content.Context
    import de.kolping.cockpit.mapping.core.currentTimeMillis
    import java.io.File
    
    /**
     * Session store for writing export files to disk.
     * Manages export directory and file operations.
     */
    class SessionStore(private val context: Context) {
        
        private val exportDir: File
            get() = File(context.filesDir, "mapping_exports").apply {
                mkdirs()
            }
        
        /**
         * Write export files from controller to disk.
         */
        fun writeExport(exports: Map<String, String>): File {
            val timestamp = currentTimeMillis()
            val exportFolder = File(exportDir, "export_$timestamp").apply {
                mkdirs()
            }
            
            exports.forEach { (path, content) ->
                val file = File(exportFolder, path)
                file.parentFile?.mkdirs()
                file.writeText(content)
            }
            
            return exportFolder
        }
        
        /**
         * List all export folders.
         */
        fun listExports(): List<File> {
            return exportDir.listFiles()?.filter { it.isDirectory }?.sortedByDescending { it.name } ?: emptyList()
        }
        
        /**
         * Delete an export folder.
         */
        fun deleteExport(exportFolder: File): Boolean {
            return exportFolder.deleteRecursively()
        }
        
        /**
         * Get the exports directory path.
         */
        fun getExportsPath(): String {
            return exportDir.absolutePath
        }
    }

- path: kmp/mapping/android/src/main/java/de/kolping/cockpit/mapping/android/ui/RecorderScreen.kt
  content: |
    package de.kolping.cockpit.mapping.android.ui
    
    import android.annotation.SuppressLint
    import androidx.compose.foundation.layout.*
    import androidx.compose.material3.*
    import androidx.compose.runtime.*
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.platform.LocalContext
    import androidx.compose.ui.unit.dp
    import androidx.compose.ui.viewinterop.AndroidView
    import de.kolping.cockpit.mapping.android.RecorderController
    import de.kolping.cockpit.mapping.android.SessionStore
    import de.kolping.cockpit.mapping.android.web.RecorderWebView
    
    @OptIn(ExperimentalMaterial3Api::class)
    @SuppressLint("SetJavaScriptEnabled")
    @Composable
    fun RecorderScreen(
        onBack: () -> Unit,
        modifier: Modifier = Modifier,
    ) {
        val context = LocalContext.current
        val controller = remember { RecorderController() }
        val sessionStore = remember { SessionStore(context) }
        
        var chainName by remember { mutableStateOf("") }
        var targetUrlName by remember { mutableStateOf("") }
        var currentUrl by remember { mutableStateOf("") }
        var showUrlDialog by remember { mutableStateOf(false) }
        var showExportDialog by remember { mutableStateOf(false) }
        var exportPath by remember { mutableStateOf("") }
        
        // Capture filters state
        var redactEnabled by remember { mutableStateOf(true) }
        var captureJsonBodies by remember { mutableStateOf(true) }
        
        // Update controller filters when changed
        LaunchedEffect(redactEnabled, captureJsonBodies) {
            controller.captureFilters = controller.captureFilters.copy(
                redact = redactEnabled,
                captureJsonBodies = captureJsonBodies
            )
        }
        
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text("Website Recorder") },
                    navigationIcon = {
                        TextButton(onClick = onBack) {
                            Text("Back")
                        }
                    }
                )
            }
        ) { padding ->
            Column(
                modifier = modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                // Chain name input
                OutlinedTextField(
                    value = chainName,
                    onValueChange = { chainName = it },
                    label = { Text("Chain Name") },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = controller.currentChain == null
                )
                
                // Control buttons row 1
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(
                        onClick = {
                            if (chainName.isNotBlank()) {
                                controller.createChain(chainName)
                            }
                        },
                        enabled = controller.currentChain == null && chainName.isNotBlank(),
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Create Chain")
                    }
                    
                    Button(
                        onClick = { controller.startSession() },
                        enabled = controller.currentChain != null && !controller.isRecording,
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Start Recording")
                    }
                }
                
                // Control buttons row 2
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(
                        onClick = { controller.stopSession() },
                        enabled = controller.isRecording,
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Stop Recording")
                    }
                    
                    Button(
                        onClick = { showUrlDialog = true },
                        enabled = controller.currentChain != null && currentUrl.isNotBlank(),
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Save Target URL")
                    }
                }
                
                // Export button
                Button(
                    onClick = {
                        val exports = controller.exportData()
                        val folder = sessionStore.writeExport(exports)
                        exportPath = folder.absolutePath
                        showExportDialog = true
                    },
                    enabled = controller.currentChain != null,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Export Bundle")
                }
                
                // Toggle switches
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Row {
                        Text("Redact:")
                        Spacer(Modifier.width(8.dp))
                        Switch(
                            checked = redactEnabled,
                            onCheckedChange = { redactEnabled = it }
                        )
                    }
                    
                    Row {
                        Text("Capture JSON:")
                        Spacer(Modifier.width(8.dp))
                        Switch(
                            checked = captureJsonBodies,
                            onCheckedChange = { captureJsonBodies = it }
                        )
                    }
                }
                
                // Status indicators
                if (controller.isRecording) {
                    Text(
                        "⏺️ Recording...",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.error
                    )
                }
                
                controller.currentChain?.let { chain ->
                    Text(
                        "Chain: ${chain.name} (${controller.chainPoints.size} points)",
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                
                if (currentUrl.isNotBlank()) {
                    Text(
                        currentUrl,
                        style = MaterialTheme.typography.bodySmall,
                        maxLines = 1
                    )
                }
                
                // WebView
                AndroidView(
                    factory = { ctx ->
                        RecorderWebView(ctx, controller).apply {
                            onUrlChanged = { currentUrl = it }
                            loadUrl("https://portal.kolping-hochschule.de/my/")
                        }
                    },
                    modifier = Modifier.fillMaxSize()
                )
            }
        }
        
        // Save URL Dialog
        if (showUrlDialog) {
            AlertDialog(
                onDismissRequest = { showUrlDialog = false },
                title = { Text("Save Target URL") },
                text = {
                    Column {
                        Text("URL: $currentUrl")
                        Spacer(Modifier.height(8.dp))
                        OutlinedTextField(
                            value = targetUrlName,
                            onValueChange = { targetUrlName = it },
                            label = { Text("Name") }
                        )
                    }
                },
                confirmButton = {
                    TextButton(
                        onClick = {
                            if (targetUrlName.isNotBlank()) {
                                controller.saveTargetUrl(currentUrl, targetUrlName)
                                targetUrlName = ""
                                showUrlDialog = false
                            }
                        }
                    ) {
                        Text("Save")
                    }
                },
                dismissButton = {
                    TextButton(onClick = { showUrlDialog = false }) {
                        Text("Cancel")
                    }
                }
            )
        }
        
        // Export Success Dialog
        if (showExportDialog) {
            AlertDialog(
                onDismissRequest = { showExportDialog = false },
                title = { Text("Export Complete") },
                text = { Text("Exported to: $exportPath") },
                confirmButton = {
                    TextButton(onClick = { showExportDialog = false }) {
                        Text("OK")
                    }
                }
            )
        }
    }

- path: kmp/mapping/android/src/main/java/de/kolping/cockpit/mapping/android/web/RecorderWebView.kt
  content: |
    package de.kolping.cockpit.mapping.android.web
    
    import android.annotation.SuppressLint
    import android.content.Context
    import android.webkit.WebResourceRequest
    import android.webkit.WebView
    import android.webkit.WebViewClient
    import de.kolping.cockpit.mapping.android.JsBridge
    import de.kolping.cockpit.mapping.android.RecorderController
    
    /**
     * Custom WebView for recording with JavaScript bridge and injection.
     */
    @SuppressLint("SetJavaScriptEnabled")
    class RecorderWebView(
        context: Context,
        private val controller: RecorderController
    ) : WebView(context) {
        
        var onUrlChanged: (String) -> Unit = {}
        
        init {
            settings.javaScriptEnabled = true
            settings.domStorageEnabled = true
            
            // Add JavaScript bridge
            addJavascriptInterface(JsBridge(controller, this), JsBridge.BRIDGE_NAME)
            
            webViewClient = object : WebViewClient() {
                override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {
                    val url = request?.url?.toString() ?: return false
                    onUrlChanged(url)
                    return false
                }
                
                override fun onPageFinished(view: WebView?, url: String?) {
                    super.onPageFinished(view, url)
                    url?.let { onUrlChanged(it) }
                    
                    // Inject capture scripts if recording
                    if (controller.isRecording) {
                        view?.evaluateJavascript(InjectionScripts.CAPTURE_NETWORK, null)
                    }
                }
            }
        }
    }

- path: kmp/mapping/android/src/main/java/de/kolping/cockpit/mapping/android/web/InjectionScripts.kt
  content: |
    package de.kolping.cockpit.mapping.android.web
    
    /**
     * JavaScript injection scripts for capturing network activity and clicks.
     * Wraps fetch and XMLHttpRequest, emits events to RecorderBridge.
     */
    object InjectionScripts {
        
        const val CAPTURE_NETWORK = """
    (function(){
      if(window.__kolpingRecorderInstalled) return;
      window.__kolpingRecorderInstalled = true;
      
      console.log('[RecorderBridge] Installing capture hooks');
      
      // Helper to generate unique IDs
      let requestIdCounter = 0;
      function genId() {
        return 'req_' + Date.now() + '_' + (++requestIdCounter);
      }
      
      // Helper to get CSS path
      function getCssPath(el) {
        if (!el) return '';
        const path = [];
        while (el && el.nodeType === Node.ELEMENT_NODE) {
          let selector = el.nodeName.toLowerCase();
          if (el.id) {
            selector += '#' + el.id;
            path.unshift(selector);
            break;
          } else {
            let sibling = el;
            let nth = 1;
            while (sibling.previousElementSibling) {
              sibling = sibling.previousElementSibling;
              if (sibling.nodeName.toLowerCase() === selector) nth++;
            }
            if (nth > 1) selector += ':nth-of-type(' + nth + ')';
            path.unshift(selector);
          }
          el = el.parentElement;
        }
        return path.join(' > ');
      }
      
      // Wrap fetch
      const origFetch = window.fetch;
      window.fetch = async function(...args) {
        const reqId = genId();
        const url = typeof args[0] === 'string' ? args[0] : args[0]?.url || '';
        const options = args[1] || {};
        const method = options.method || 'GET';
        const body = options.body ? String(options.body) : null;
        const headers = options.headers || {};
        
        try {
          window.RecorderBridge?.postMessage(JSON.stringify({
            type: 'request',
            data: { id: reqId, method, url, body, headers: Object.fromEntries(new Headers(headers)) }
          }));
        } catch(e) { console.error('[RecorderBridge] Error sending request:', e); }
        
        try {
          const response = await origFetch.apply(this, args);
          const clonedRes = response.clone();
          
          // Read response body asynchronously
          clonedRes.text().then(bodyText => {
            try {
              window.RecorderBridge?.postMessage(JSON.stringify({
                type: 'response',
                data: {
                  requestId: reqId,
                  status: response.status,
                  headers: Object.fromEntries(response.headers),
                  body: bodyText,
                  contentType: response.headers.get('content-type'),
                  url: url
                }
              }));
            } catch(e) { console.error('[RecorderBridge] Error sending response:', e); }
          }).catch(e => console.error('[RecorderBridge] Error reading response body:', e));
          
          return response;
        } catch(error) {
          console.error('[RecorderBridge] Fetch error:', error);
          throw error;
        }
      };
      
      // Wrap XMLHttpRequest
      const XHR = XMLHttpRequest.prototype;
      const origOpen = XHR.open;
      const origSend = XHR.send;
      
      XHR.open = function(method, url, ...rest) {
        this.__rec_id = genId();
        this.__rec_method = method;
        this.__rec_url = url;
        return origOpen.call(this, method, url, ...rest);
      };
      
      XHR.send = function(body) {
        const reqId = this.__rec_id;
        const method = this.__rec_method;
        const url = this.__rec_url;
        
        try {
          window.RecorderBridge?.postMessage(JSON.stringify({
            type: 'request',
            data: { id: reqId, method, url, body: body ? String(body) : null, headers: {} }
          }));
        } catch(e) { console.error('[RecorderBridge] Error sending XHR request:', e); }
        
        this.addEventListener('load', function() {
          try {
            window.RecorderBridge?.postMessage(JSON.stringify({
              type: 'response',
              data: {
                requestId: reqId,
                status: this.status,
                headers: {},
                body: this.responseText,
                contentType: this.getResponseHeader('content-type'),
                url: url
              }
            }));
          } catch(e) { console.error('[RecorderBridge] Error sending XHR response:', e); }
        });
        
        return origSend.call(this, body);
      };
      
      // Capture clicks
      document.addEventListener('click', function(e) {
        try {
          const cssPath = getCssPath(e.target);
          const targetUrl = e.target.href || null;
          
          window.RecorderBridge?.postMessage(JSON.stringify({
            type: 'click',
            data: { cssPath, targetUrl }
          }));
        } catch(err) { console.error('[RecorderBridge] Error capturing click:', err); }
      }, true);
      
      console.log('[RecorderBridge] Capture hooks installed successfully');
    })();
    """
    }

- path: kmp/recorder/app/build.gradle.kts
  content: |
    plugins {
        id("com.android.application")
        kotlin("android")
    }
    
    android {
        namespace = "de.kolping.cockpit.recorderapp"
        compileSdk = 35
    
        defaultConfig {
            applicationId = "de.kolping.cockpit.recorderapp"
            minSdk = 26
            targetSdk = 35
            versionCode = 1
            versionName = "0.1.0"
        }
        
        buildFeatures {
            compose = true
        }
        
        composeOptions {
            kotlinCompilerExtensionVersion = libs.versions.compose.compiler.get()
        }
    }
    
    dependencies {
        implementation(project(":mapping:android"))
        implementation(libs.activity.compose)
        implementation(libs.compose.ui)
        implementation(libs.compose.material3)
    }

- path: kmp/recorder/app/src/main/AndroidManifest.xml
  content: |
    <manifest xmlns:android="http://schemas.android.com/apk/res/android">
      <uses-permission android:name="android.permission.INTERNET" />
      <application android:label="RecorderApp">
        <activity android:name=".RecorderAppActivity" android:exported="true">
          <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
          </intent-filter>
        </activity>
      </application>
    </manifest>

- path: kmp/recorder/app/src/main/java/de/kolping/cockpit/recorderapp/RecorderAppActivity.kt
  content: |
    package de.kolping.cockpit.recorderapp
    
    import android.os.Bundle
    import androidx.activity.ComponentActivity
    import androidx.activity.compose.setContent
    import de.kolping.cockpit.mapping.android.ui.RecorderScreen
    
    class RecorderAppActivity : ComponentActivity() {
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
                RecorderScreen(onBack = { finish() })
            }
        }
    }

patches:
- id: settings_includes
  diff: |
    --- a/kmp/settings.gradle.kts
    +++ b/kmp/settings.gradle.kts
    @@ -20,3 +20,6 @@
     
     include(":shared")
     include(":androidApp")
    +include(":mapping:core")
    +include(":mapping:android")
    +include(":recorder:app")
- id: androidApp_deps
  diff: |
    --- a/kmp/androidApp/build.gradle.kts
    +++ b/kmp/androidApp/build.gradle.kts
    @@ -57,6 +57,8 @@
     
     dependencies {
         implementation(project(":shared"))
    +    implementation(project(":mapping:core"))
    +    implementation(project(":mapping:android"))
         
         // Kotlin
         implementation(libs.kotlin.stdlib)
- id: mainactivity_recorder_screen
  diff: |
    --- a/kmp/androidApp/src/main/java/de/kolping/cockpit/android/MainActivity.kt
    +++ b/kmp/androidApp/src/main/java/de/kolping/cockpit/android/MainActivity.kt
    @@ -13,6 +13,7 @@
     import de.kolping.cockpit.android.ui.theme.KolpingCockpitTheme
     import org.koin.android.ext.android.inject
     
    +import de.kolping.cockpit.mapping.android.ui.RecorderScreen
     class MainActivity : ComponentActivity() {
         
         private val tokenManager: TokenManager by inject()
    @@ -65,6 +66,7 @@
             
             Screen.Home -> {
                 HomeScreen(
    +                onNavigateToRecorder = { currentScreen = Screen.Recorder },
                     onNavigateToModuleDetail = { moduleId ->
                         selectedModuleId = moduleId
                         previousScreen = Screen.Home
    @@ -142,6 +144,10 @@
                 )
             }
             
    +        Screen.Recorder -> {
    +            RecorderScreen(onBack = { currentScreen = Screen.Home })
    +        }
    +
             Screen.PdfViewer -> {
                 selectedFilePath?.let { filePath ->
                     PdfViewerScreen(
    @@ -186,4 +192,5 @@
         object ModuleDetail : Screen()
         object OfflineLibrary : Screen()
         object PdfViewer : Screen()
    +    object Recorder : Screen()
     }
- id: homescreen_recorder_entry
  diff: |
    --- a/kmp/androidApp/src/main/java/de/kolping/cockpit/android/ui/screens/HomeScreen.kt
    +++ b/kmp/androidApp/src/main/java/de/kolping/cockpit/android/ui/screens/HomeScreen.kt
    @@ -23,6 +23,7 @@
     @OptIn(ExperimentalMaterial3Api::class)
     @Composable
     fun HomeScreen(
    +    onNavigateToRecorder: () -> Unit = {},
         onNavigateToModuleDetail: (String) -> Unit = {},
         onNavigateToCalendar: () -> Unit = {},
         onNavigateToOfflineLibrary: () -> Unit = {},
